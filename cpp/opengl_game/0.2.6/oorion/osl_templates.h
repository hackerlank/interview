#define BREAK_SYMBOL ' '
#define QUOTE_SYMBOL '"'

enum E_OSL_TEMPLATE { 
				E_OSL_DECLARE_VAR_TEMPLATE,
				E_OSL_ASSIGN_VAR_TEMPLATE,
				E_OSL_DECLARE_ASSIGN_VAR_TEMPLATE,
				E_OSL_DECLARE_FUNCTION_TEMPLATE,
				E_OSL_FUNCTION_CALL_TEMPLATE,
				E_OSL_IF_TEMPLATE,
				E_OSL_IF_ELSE_TEMPLATE,
				E_OSL_WHILE_TEMPLATE,
				E_OSL_DO_TEMPLATE,
				E_OSL_NO_TEMPLATE
};

enum E_OSL_TEMPLATE_PATTERN {
				E_OSL_TYPE,
				E_OSL_NAME,
				E_OSL_MATH,
				E_OSL_PARAM,
				E_OSL_CONDITION,
				E_OSL_CODE,
				E_OSL_FUNC,
				E_OSL_IF,
				E_OSL_WHILE,
				E_OSL_ELSE,
				E_OSL_DO,
				E_OSL_FUNCTION,
				E_OSL_VARIABLE,
				E_OSL_LEFT_BRACKET,
				E_OSL_RIGHT_BRACKET,
				E_OSL_LEFT_BRACE,
				E_OSL_RIGHT_BRACE,
				E_OSL_SEMICOLON,
				E_OSL_EQUALCOLON,
				E_OSL_NO_PATTERN
};


typedef struct tagOSL_TEMPLATE {

	vector<E_OSL_TEMPLATE_PATTERN> tmplt;
	E_OSL_TEMPLATE type;

	tagOSL_TEMPLATE();

	bool Match(vector<LEXEM>* lexems);

} OSL_TEMPLATE;


typedef struct tagOSL_TEMPLATE_STORAGE {

	vector<OSL_TEMPLATE> templates;

	tagOSL_TEMPLATE_STORAGE();

	void AddTemplate(E_OSL_TEMPLATE type, vector<E_OSL_TEMPLATE_PATTERN> tmplt);
	E_OSL_TEMPLATE MatchLexems(vector<LEXEM>* lexems);

} OSL_TEMPLATE_STORAGE;

	

